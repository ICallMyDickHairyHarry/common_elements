# Импортируем библиотеку для тестов и нашу функцию из соседнего файла

import unittest

from common_elements import common_elements

# Создаём списки(массивы) на все случаи жизни

usual_list_1 = [1, 592, 5, -2, 88005553535, 10, 3, 666, 2, 0]  # обычные списки
usual_list_2 = [5, -78, 434, 32, 7777, -12, 65, 90, 32]

empty_list = []  # пустой список

small_list_1 = [2, 54]  # маленький список
small_list_2 = [1]  # список из одного элемента

long_list = [32, 54, -66, 11, 3222, 4, 1, -5, 5, 15, 9, -87, 342, 76, 98, 33333, -13344, 8786, 24, 878,
             -52, 2341, 653, 122]  # большой список
long_list_but_its_actually_long = [i for i in range(-10**3, 10**3)]  # (не)большой список (2000 элементов)
# список всех целых цисел от -1000 до 999

fully_loaded_negative = [-643, -33, -54, -4, -123, -2, -10, -10001, -43, -2]
# список, в котором все числа отрицательны
fully_loaded_positive = [8, 1, 54, 55, 23, 122, 433, 11, 34, 10, 4333, 43, 2]
# список, в котором все числа положительны

# заносим все наши списки в массив
lists = [usual_list_1, usual_list_2, empty_list, small_list_1, small_list_2, long_list, long_list_but_its_actually_long,
         fully_loaded_negative, fully_loaded_positive]

# так как в условии задачи сказано, что можно считать, что элементы не повторяются,
# то созданные массивы сразу превращаем в сеты
# (сет - множество, массив, который не содержит одинаковых элементов)
lists = list(map(set, lists))
# функция map() применяет данную ей функцию (в нашем случае set()) к каждом элементу данного ей списка
# (в нашем случае lists), так как функция map возвращает map object, то мы делаем из него список

# теперь следует посмотреть, что делает функция common_elements, которая находится в одноимённом файле,
# потом продолжить читать этот файл

# создаём список с правильными ответами для тестов
right_answers = [1, 0, 1, 1, 2, 9, 1, 3, 0, 0, 0, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 2, 1, 1, 0, 1, 19, 0, 4, 8,
                 12, 0]

counter = 0  # про counter будет объяснено далее

if __name__ == '__main__':  # следующей код выполняется, если программу запускают из командной строки

    # создаём класс с тестирующей функцией, которая принимает 2 сета и правильный ответ - кол-во общих элементов
    # у этих сетов
    # затем эта функция применяет функцию common_elements() к этим сетам и сравнивает результат с правильным ответом
    # с помощью assertEqual()
    # если результат != правильному ответу, то assertEqual() вызывает ошибку
    class CommonTest(unittest.TestCase):
        def test_function(self, list_1, list_2, right_answer):
            number_of_commons = common_elements(list_1, list_2)
            self.assertEqual(number_of_commons, right_answer)

    # создаём объект класса
    TestObject = CommonTest()

    # двумя циклами проходимся по lists и поочерёдно передаём его элементы тестирующей функции
    # с помощью counter'а передаём нужный правильный ответ из right_answers тестирующей функции
    for i in range(len(lists)):
        for j in range(i+1, len(lists)):
            TestObject.test_function(lists[i], lists[j], right_answers[counter])
            counter += 1
    print("Все тесты пройдены успешно")
    print("Создаём ошибку, чтобы показать, что тесты действительно работают...")
    print("...")

    # чтобы создать ошибку передаём тестирующей функции usual_list_1 и empty_list, а также правильный ответ, равный 2
    # Истинный правильный ответ равен 0, поэтому программа выдаёт ошибку
    TestObject.test_function(lists[0], lists[2], 2)
